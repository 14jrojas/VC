# -*- coding: utf-8 -*-
"""Copia de TemplateAssignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fzDGMYnah9cpdSW7YrzjaFxDsmDHvwIz

---
"""

import sys,os
# Let's import the python module P0. 
# You must create the directory CV and put inside the file P0.py
# P0.py is the module created from your notebook P0.
path_to_module='/content/drive/My Drive/CV/'
sys.path.append(os.path.abspath(path_to_module))

import P0

# Commented out IPython magic to ensure Python compatibility.
# We import the modules to use
import cv2, numpy as np, math
from matplotlib import pyplot as plt
# This allows to display images  and to save  them in cells
# %matplotlib inline

def gaussianMask1D(sigma=0, sizeMask=0, order=0):
  if sigma != 0:
    sizeMask = int(6*sigma)+1
  elif sizeMask != 0:
      sigma = (sizeMask-1)/6

  # elegimos k tal que k sea el entero más pequeño que cumple k >= 3*sigma
  # si sigma = 1, k = 3, pero si sigma = 1.1, 3*sigma = 3.3 -> k = 4 
  k = np.ceil(3*sigma)
  x = np.arange(-k, k+1, 1, dtype=np.int_)

  mask = pow(np.e, (-0.5*x**2)/(sigma**2))  
  if order == 0:
    mask = mask/np.sum(mask) # tiene que sumar 1, por lo que normalizamos
  elif order == 1:
    mask = -x/sigma*mask
  elif order == 2:
    mask = (x**2/sigma**2-1)*mask

  return mask

def plotGraph(graph, title='No title'):
  k = (len(graph)-1)/2
  plt.plot(np.arange(-k,k+1,1,dtype=np.int_),graph)
  plt.title(title)
  plt.show()

# orders es un vector de dos valores [filas,columnas]
def my2DConv(im, sigma, orders):
  # A partir de estos ordenes podemos obtener el resto
  if orders == [0,0]:
    return cv2.sepFilter2D(src=im, ddepth=-1, kernelX=gaussianMask1D(sigma, sizeMask=0, order=0), kernelY=gaussianMask1D(sigma, sizeMask=0, order=0))
  elif orders == [1,0]:
    return cv2.sepFilter2D(src=im, ddepth=-1, kernelX=gaussianMask1D(sigma, sizeMask=0, order=1), kernelY=gaussianMask1D(sigma, sizeMask=0, order=0))
  elif orders == [0,1]:
    return cv2.sepFilter2D(src=im, ddepth=-1, kernelX=gaussianMask1D(sigma, sizeMask=0, order=0), kernelY=gaussianMask1D(sigma, sizeMask=0, order=1))
  elif orders == [2,0]:
    return cv2.sepFilter2D(src=im, ddepth=-1, kernelX=gaussianMask1D(sigma, sizeMask=0, order=2), kernelY=gaussianMask1D(sigma, sizeMask=0, order=0))
  elif orders == [0,2]:
    return cv2.sepFilter2D(src=im, ddepth=-1, kernelX=gaussianMask1D(sigma, sizeMask=0, order=0), kernelY=gaussianMask1D(sigma, sizeMask=0, order=2))
  else:
    ('error in order of derivative')

def gradientIM(im,sigma):
  dx = my2DConv(im,sigma,[1,0])
  dy = my2DConv(im,sigma,[0,1])

  return dx,dy

def laplacianG(im,sigma):
  return sigma**2*(my2DConv(im,sigma,[2,0])+my2DConv(im,sigma,[0,2]))

def displayPyramid(pyrG, title=''):
  bn = True
  if len(pyrG[0].shape) == 3:
    bn = False 

  listh = [] # listh contendrá la primera imagen (la más grande) y el resto de imágenes unidas verticalmente
  listv = [] # listv contendrá todas las imágenes menos la primera unidas verticalmente
  listh.append(pyrG[0])

  listv.append(pyrG[1])
  i = 2
  while i < len(pyrG):
    aux = pyrG[i]
    aux = np.hstack([aux,np.zeros((aux.shape[0],listv[0].shape[1]-aux.shape[1]))]) if bn else np.hstack([aux,np.zeros((aux.shape[0],listv[0].shape[1]-aux.shape[1],3))])
    listv.append(aux)
    i = i + 1 
    
  sum = np.sum([elem.shape[0] for elem in listv])

  listv.append(np.zeros((listh[0].shape[0]-sum,listv[0].shape[1]))) if bn else listv.append(np.zeros((listh[0].shape[0]-sum,listv[0].shape[1],3)))
  aux = np.vstack(listv)
  listh.append(aux)
  im = np.hstack(listh)

  P0.displayIm(im,title,factor=2)

def pyramidGauss(im, sizeMask=7, nlevel=4):
  vim = [im]
  sigma = (sizeMask-1)/6

  for i in range(nlevel):
    # aplicamos el alisamiento
    aux = my2DConv(vim[i],sigma,[0,0])
    rows = []
    for j in range(aux.shape[0]):
      if j%2 == 1:
        rows.append(j)
    # eliminamos filas
    imlevel = np.delete(aux,rows,0)
    cols = []
    aux = imlevel
    for j in range(aux.shape[1]):
      if j%2 == 1:
        cols.append(j)
    # eliminamos columnas
    imlevel = np.delete(aux,cols,1)
    # añadimos la imagen a la pirámide
    vim.append(imlevel)
  
  return vim

def pyramidLap(im, sizeMask,nlevel=4,flagInterp=cv2.INTER_LINEAR):
  vimG = pyramidGauss(im,sizeMask,nlevel)

  vimL = []
  for i in range(nlevel-1):
    # resize a la siguiente imagen con el flag pasado como argumento
    aux = cv2.resize(vimG[i+1],(vimG[i].shape[1],vimG[i].shape[0]),1,1,flagInterp)
    # calculamos la diferencia
    vimL.append(vimG[i]-aux)  
  vimL.append(vimG[nlevel-1])

  return vimL

def reconstructIm(pyL,flagInterp):
  # ordenamos de menor a mayor las imágenes
  pyLo = []
  for i in range(len(pyL)):
    pyLo.append(pyL[len(pyL)-i-1])

  im = pyLo[0]
  for i in range(len(pyLo)-1):
    # resize a la siguiente imagen con el flag de interpolacion
    aux = cv2.resize(im,(pyLo[i+1].shape[1],pyLo[i+1].shape[0]),1,1,flagInterp)
    # calculamos la suma
    im = aux + pyLo[i+1]

  return im

def lowIm(im,sigma):
  return my2DConv(im,sigma,[0,0])

def highIm(im,sigma):
  return im - lowIm(im,sigma)

def hybridIm(im1,im2,sigma1,sigma2):
  return (lowIm(im1,sigma1)+highIm(im2,sigma2))/2

"""El efecto visual que percibimos es que, en primera instancia, percibimos o podemos apreciar mayoritariamente una imagen, pero conforme avanzamos en la piramide (que modela un efecto similar al de alejarnos de la imagen) podemos apreciar una imagen distinta, como era de esperar según explica el paper."""